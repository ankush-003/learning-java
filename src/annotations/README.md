# Annotations
annotations in Java are used to provide information about the code. It is used to provide metadata to the code. Annotations do not change action of a compiled program.
## Examples
- @Override: When we override a method, we use this annotation to inform the compiler that the method is overridden from parent class.
- @Deprecated: This annotation is used to inform the compiler to generate a warning when a deprecated method is used.
- @SuppressWarnings: This annotation is used to suppress warnings generated by the compiler.
- @FunctionalInterface: This annotation is used to ensure that the functional interface canâ€™t have more than one abstract method. (Functional Interface is an interface that has only one abstract method. It can have any number of default and static methods. It can also declare methods of object class.)

## Creating Custom Annotations
- @Target: This annotation is used to specify the allowed locations for annotations. It specifies the possible elements which can be annotated by a custom annotation.
- ElementType: This is an enum defined in java.lang.annotation package. It specifies the type of the element to which an annotation can be applied. It can be TYPE, METHOD, CONSTRUCTOR, FIELD, etc.
- @Retention: This annotation is used to specify how the marked annotation is stored. It is used to specify whether the annotation is stored only in the source code or is stored in the compiled class files or it is available at runtime.
  - RetentionPolicy: This is an enum defined in java.lang.annotation package. It specifies the retention policy to be used. It can have SOURCE, CLASS or RUNTIME as its value.
  - SOURCE: Annotations are to be discarded by the compiler.
  - CLASS: Annotations are to be recorded in the class file by the
  - compiler but need not be retained by the VM at run time.
  - RUNTIME: Annotations are to be recorded in the class file by the